I"<h1 id="해쉬테이블hashtable">해쉬테이블(HashTable)</h1>

<p>해쉬테이블은 효율적인 <b>탐색</b>을 위한 자료구조로서 키를 값에 대응시킨다. 가장 기본적인 해쉬테이블의 구현은 해쉬 코드와 연결리스트, 배열만 있으면 된다.</p>

<h2 id="방법">방법</h2>

<ol>
  <li>키의 해쉬 코드를 계산한다</li>
  <li>hash(key) % arrayLegnth와 같은 방법으로 해쉬 코드를 이용해 배열의 인덱스를 구한다.</li>
  <li>배열의 각 인덱스에는 키와 값으로 이루어진 연결리스트가 존재한다.</li>
</ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>항상 충돌에 대비해야 한다. 

여기서 말하는 충돌이란 서로 다른 두 개의 키가 같은 해쉬 코드를 가리키거나 서로 다른 두 개의 해쉬 코드가 같은 인덱스를 가르키는 것을 의미한다.
</code></pre></div></div>

<h2 id="결론">결론</h2>

<p>키에 상응하는 값을 찾기 위해선 위의 과정을 반복해야 한다. 주어진 키로 해쉬 코드를 계산하고, 이 해쉬 코드를 이용해 인덱스를 계산한다. 그 다음엔 키에 상응하는 값을 연결리스트에서 탐색한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>충돌이 자주 발생한다면, 최악의 경우 O(N)이 된다. 하지만 일반적으로 해쉬에 대해 이야기할 때는 충돌을 최소화하도록 잘 구현된 경우를 가정하는데 이 경우에 탐색 시간은 O(1)이다.
</code></pre></div></div>

<p><img src="http://localhost:4000/assets/images/posts/image_hash_table.png" alt="Unsplash image 9" />
<img src="{{ site.url }}{{ site.baseurl }}/assets/images/posts/image_hash_table.png" alt="" /></p>

<h2 id="다른방법">다른방법?</h2>

<p>또 다른 구현법으로는 균형 이진 탐색 트리를 사용하는 방법이 있다. 이 경우에 탐색 시간은 O(log N)이 된다. 이 방법은 크기가 큰 배열을 미리 할당해 놓지 않아도 되기 때문에 작은 공간을 사용한다는 장점이 있다. 또한 키의 집합을 특정 순서로 차례대로 접근할 수 있는데, 어떤 경우에는 이런 기능이 유용하기도 한다.</p>
:ET